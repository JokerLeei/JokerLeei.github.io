<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JokerLee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-03T05:00:54.472Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JokerLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis一级缓存&amp;二级缓存</title>
    <link href="http://yoursite.com/2020/03/03/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98&amp;%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/03/03/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98&amp;%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2020-03-03T04:04:38.000Z</published>
    <updated>2020-03-03T05:00:54.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><h3 id="SqlSession-级别，同一个-SqlSession-对象中有个-HashMap-用于存储缓存数据。"><a href="#SqlSession-级别，同一个-SqlSession-对象中有个-HashMap-用于存储缓存数据。" class="headerlink" title="SqlSession 级别，同一个 SqlSession 对象中有个 HashMap 用于存储缓存数据。"></a>SqlSession 级别，同一个 SqlSession 对象中有个 HashMap 用于存储缓存数据。</h3><p>MyBatis 默认只开启一级缓存，在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p><p><img src="/2020/03/03/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98&%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/MyBatis1.png" alt="MyBatis一级缓存"></p><h3 id="使用一级缓存"><a href="#使用一级缓存" class="headerlink" title="使用一级缓存"></a>使用一级缓存</h3><ol><li>同一个 SqlSession 对象</li><li>同一个查询<ol><li>传入的 statementId</li><li>查询时要求的 ResultSet 范围</li><li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）</li><li>传递给 java.sql.Statement 要设置的参数值</li></ol></li></ol><h3 id="一级缓存生命周期"><a href="#一级缓存生命周期" class="headerlink" title="一级缓存生命周期"></a>一级缓存生命周期</h3><ol><li>MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</li><li>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</li><li>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用</li></ol><hr><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><h3 id="namespace-级别，不同-SqlSession-执行相同-namespace-下的-sql-语句（参数相同）"><a href="#namespace-级别，不同-SqlSession-执行相同-namespace-下的-sql-语句（参数相同）" class="headerlink" title="namespace 级别，不同 SqlSession 执行相同 namespace 下的 sql 语句（参数相同）"></a>namespace 级别，不同 SqlSession 执行相同 namespace 下的 sql 语句（参数相同）</h3><p>MyBatis 的二级缓存默认不开启，是 Application 级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。</p><h3 id="MyBatis的缓存机制整体设计以及二级缓存的工作模式"><a href="#MyBatis的缓存机制整体设计以及二级缓存的工作模式" class="headerlink" title="MyBatis的缓存机制整体设计以及二级缓存的工作模式"></a>MyBatis的缓存机制整体设计以及二级缓存的工作模式</h3><p><img src="/2020/03/03/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98&%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/MyBatis2.png" alt="MyBatis二级缓存"></p><p>实现二级缓存的时候，MyBatis 要求返回的 POJO 必须是可以被序列化的。</p><p>配置方法：</p><ol><li>在配置文件中开启二级缓存</li><li>在映射文件里配置 &lt;cache/&gt;</li></ol><p>配置了二级缓存，意味着：</p><ul><li>映射语句文件中的所有select语句将会被缓存。</li><li>映射语句文件中的所欲insert、update和delete语句会刷新缓存。</li><li>缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。</li><li>根据时间表，比如No Flush Interval,（CNFI没有刷新间隔），缓存不会以任何时间顺序来刷新。</li><li>缓存会存储列表集合或对象(无论查询方法返回什么)的1024个引用</li><li>缓存会被视为是read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="一、创建一个-POJO-并序列化"><a href="#一、创建一个-POJO-并序列化" class="headerlink" title="一、创建一个 POJO 并序列化"></a>一、创建一个 POJO 并序列化</h3><p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。(如果存储在内存中的话，实测不序列化也可以的。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">735655488285535299L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Teacher&gt; teachers;</span><br><span class="line"></span><br><span class="line">    setters&amp;getters()....;</span><br><span class="line"></span><br><span class="line">    toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、在-mybatis-config-xml（配置文件）中开启二级缓存"><a href="#二、在-mybatis-config-xml（配置文件）中开启二级缓存" class="headerlink" title="二、在  mybatis-config.xml（配置文件）中开启二级缓存"></a>二、在  mybatis-config.xml（配置文件）中开启二级缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个配置使全局的映射器(二级缓存)启用或禁用缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、在-xxxMapper-xml（映射文件）中开启二级缓存并配置"><a href="#三、在-xxxMapper-xml（映射文件）中开启二级缓存并配置" class="headerlink" title="三、在 xxxMapper.xml（映射文件）中开启二级缓存并配置"></a>三、在 xxxMapper.xml（映射文件）中开启二级缓存并配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.yihaomen.mybatis.dao.StudentMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启本mapper的namespace下的二级缓存--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        eviction:代表的是缓存回收策略，目前MyBatis提供以下策略。</span></span><br><span class="line"><span class="comment">        (1) LRU,最近最少使用的，一处最长时间不用的对象</span></span><br><span class="line"><span class="comment">        (2) FIFO,先进先出，按对象进入缓存的顺序来移除他们</span></span><br><span class="line"><span class="comment">        (3) SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象</span></span><br><span class="line"><span class="comment">        (4) WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU，</span></span><br><span class="line"><span class="comment">                移除最长时间不用的对形象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        flushInterval:刷新间隔时间，单位为毫秒，这里配置的是100秒刷新，如果你不配置它，那么当</span></span><br><span class="line"><span class="comment">        SQL被执行的时候才会去刷新缓存。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        size:引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。</span></span><br><span class="line"><span class="comment">        这里配置的是1024个对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        readOnly:只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有</span></span><br><span class="line"><span class="comment">        办法修改缓存，他的默认值是false，不允许我们修改</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">flushInterval</span>=<span class="string">"100000"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">size</span>=<span class="string">"1024"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"studentMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"gender"</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"collectionMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">extends</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"teachers"</span> <span class="attr">ofType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"teach_id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"gender"</span> <span class="attr">column</span>=<span class="string">"tgender"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"tsubject"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumTypeHandler"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"degree"</span> <span class="attr">column</span>=<span class="string">"tdegree"</span> <span class="attr">javaType</span>=<span class="string">"string"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudents"</span> <span class="attr">resultMap</span>=<span class="string">"collectionMap"</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            s.id, s.name, s.gender, t.id teach_id, t.name tname, t.gender tgender, t.subject tsubject, t.degree tdegree</span><br><span class="line">        FROM</span><br><span class="line">            student s</span><br><span class="line">        LEFT JOIN</span><br><span class="line">            stu_teach_rel str</span><br><span class="line">        ON</span><br><span class="line">            s.id = str.stu_id</span><br><span class="line">        LEFT JOIN</span><br><span class="line">            teacher t</span><br><span class="line">        ON</span><br><span class="line">            t.id = str.teach_id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以通过设置useCache来规定这个sql是否开启缓存，ture是开启，false是关闭--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAllStudents"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        SELECT id, name, age FROM student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--刷新二级缓存</span></span><br><span class="line"><span class="comment">    &lt;select id="selectAllStudents" resultMap="studentMap" flushCache="true"&gt;</span></span><br><span class="line"><span class="comment">        SELECT id, name, age FROM student</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>参考：<a href="https://www.cnblogs.com/happyflyingpig/p/7739749.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyflyingpig/p/7739749.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一级缓存&quot;&gt;&lt;a href=&quot;#一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一级缓存&quot;&gt;&lt;/a&gt;一级缓存&lt;/h1&gt;&lt;h3 id=&quot;SqlSession-级别，同一个-SqlSession-对象中有个-HashMap-用于存储缓存数据。&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>http1.0&amp;http1.1&amp;http2.0</title>
    <link href="http://yoursite.com/2020/02/29/http1.0&amp;http1.1&amp;http2.0/"/>
    <id>http://yoursite.com/2020/02/29/http1.0&amp;http1.1&amp;http2.0/</id>
    <published>2020-02-29T03:33:30.000Z</published>
    <updated>2020-02-29T04:02:37.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-0-和-TTP-1-1主要区别"><a href="#HTTP1-0-和-TTP-1-1主要区别" class="headerlink" title="HTTP1.0 和 TTP 1.1主要区别"></a><center>HTTP1.0 和 TTP 1.1主要区别</center></h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p><p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p><p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p><p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p><p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p><hr><hr><h2 id="HTTP1-1-和-HTTP2-0的主要区别"><a href="#HTTP1-1-和-HTTP2-0的主要区别" class="headerlink" title="HTTP1.1 和 HTTP2.0的主要区别"></a><center>HTTP1.1 和 HTTP2.0的主要区别</center></h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p><p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p><p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p><hr><p>参考：<a href="https://blog.csdn.net/linsongbin1/article/details/54980801" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/54980801</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP1-0-和-TTP-1-1主要区别&quot;&gt;&lt;a href=&quot;#HTTP1-0-和-TTP-1-1主要区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.0 和 TTP 1.1主要区别&quot;&gt;&lt;/a&gt;&lt;center&gt;HTTP1.0 和 TTP 1
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>排序(多图)</title>
    <link href="http://yoursite.com/2020/02/26/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/02/26/%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-26T05:04:54.000Z</published>
    <updated>2020-02-29T03:54:48.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><center>目录</center></h1><h3 id><a href="#" class="headerlink" title></a><table></table></h3><tr><td bgcolor="black"><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><center><a href="#1"><font color="red">冒泡排序</font></a></center></h3><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><center><a href="#2"><font color="Coral">选择排序</font></a></center></h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><center><a href="#3"><font color="gold">插入排序</font></a></center></h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><center><a href="#4"><font color="GreenYellow">希尔排序</font></a></center></h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><center><a href="#5"><font color="MediumAquamarine">归并排序</font></a></center></h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><center><a href="#6"><font color="Cyan">快速排序</font></a></center></h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><center><a href="#7"><font color="RoyalBlue">堆排序</font></a></center></h3><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><center><a href="#8"><font color="blue">计数排序</font></a></center></h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><center><a href="#9"><font color="BlueViolet">桶排序</font></a></center></h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><center><a href="#10"><font color="DeepPink">基数排序</font></a></center></h3></td></tr><hr><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a><center>序言</center></h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/sort.png" alt></p><hr><h1 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a><h id="1">冒泡排序<h></h></h></h1><p>冒泡排序（Bubble  Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/bubbleSort.gif" alt="冒泡排序"></p><h3 id="3-Java-代码实现"><a href="#3-Java-代码实现" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 此处 &gt; 升序；&lt;降序</span></span><br><span class="line">                arr[j] += arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a><h id="2">选择排序</h></h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/selectionSort.gif" alt="选择排序"></p><h3 id="3-Java-代码实现-1"><a href="#3-Java-代码实现-1" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[index]) &#123; <span class="comment">// 此处 &lt; 升序；&gt; 降序</span></span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != i) &#123;</span><br><span class="line">            arr[i] += arr[index];</span><br><span class="line">            arr[index] = arr[i] - arr[index];</span><br><span class="line">            arr[i] = arr[i] - arr[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a><h id="3">插入排序</h></h1><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h3 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><h3 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/insertionSort.gif" alt="插入排序"></p><h3 id="3-Java-代码实现-2"><a href="#3-Java-代码实现-2" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123; <span class="comment">// 此处 &lt; 升序；&gt; 降序</span></span><br><span class="line">                arr[j] += arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j] - arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] - arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希尔排序-1"><a href="#希尔排序-1" class="headerlink" title="希尔排序"></a><h id="4">希尔排序</h></h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p><p>按增量序列个数 k，对序列进行 k 趟排序；</p><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/shellSort.gif" alt="希尔排序"></p><h3 id="3-Java-代码实现-3"><a href="#3-Java-代码实现-3" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; arr.length) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = (<span class="keyword">int</span>) Math.floor(gap / <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a><h id="5">归并排序</h></h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）</li><li>自下而上的迭代</li></ul><h3 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/mergeSort.gif" alt="归并排序"></p><h3 id="3-Java-代码实现-4"><a href="#3-Java-代码实现-4" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;                <span class="comment">// 当子序列中只有一个元素时结束递归</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;  <span class="comment">// 划分子序列</span></span><br><span class="line">        mergeSort(arr, start, mid);   <span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, end); <span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">        merge(arr, start, mid, end);  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两路归并算法，两个排好序的子序列合并为一个子序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];        <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>, k = left;  <span class="comment">// p1、p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr[p1] &lt;= arr[p2])</span><br><span class="line">            tmp[k++] = arr[p1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) tmp[k++] = arr[p1++];   <span class="comment">// 如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= right) tmp[k++] = arr[p2++]; <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制回原素组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a><h id="6">快速排序</h></h1><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h3 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol><h3 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/quickSort.gif" alt="快速排序"></p><h3 id="3-Java-代码实现-5"><a href="#3-Java-代码实现-5" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">    <span class="keyword">int</span> pivot = left;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a><h id="7">堆排序</h></h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><h3 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h3 id="2-动图演示-6"><a href="#2-动图演示-6" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/heapSort.gif" alt="堆排序"></p><h3 id="3-Java-代码实现-6"><a href="#3-Java-代码实现-6" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造初始堆,从第一个非叶子节点开始调整,左右孩子节点中较大的交换到父节点中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.length) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        headAdjust(arr, arr.length, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序，将最大的节点放在堆尾，然后从根节点重新调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        headAdjust(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">headAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = i, temp = arr[i], index = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &lt; arr[index + <span class="number">1</span>]) &#123;</span><br><span class="line">                index = index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &gt; temp) &#123;</span><br><span class="line">            arr[k] = arr[index];</span><br><span class="line">            k = index;</span><br><span class="line">            index = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="计数排序-1"><a href="#计数排序-1" class="headerlink" title="计数排序"></a><h id="8">计数排序</h></h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>\1. 计数排序的特征</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9  位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><h3 id="1-算法步骤-7"><a href="#1-算法步骤-7" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>（1）找出待排序的数组中最大和最小的元素</p><p>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p><p>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p><p>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><h3 id="2-动图演示-7"><a href="#2-动图演示-7" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/countingSort.gif" alt="计数排序"></p><h3 id="3-Java-代码实现-7"><a href="#3-Java-代码实现-7" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue=getMaxValue(arr);</span><br><span class="line">    <span class="keyword">int</span> bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        bucket[value]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="桶排序-1"><a href="#桶排序-1" class="headerlink" title="桶排序"></a><h id="9">桶排序</h></h1><h3 id="1-算法步骤-8"><a href="#1-算法步骤-8" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ol><li><h3 id="什么时候最快"><a href="#什么时候最快" class="headerlink" title="什么时候最快"></a>什么时候最快</h3><p>当输入的数据可以均匀的分配到每一个桶中。</p></li><li><h3 id="什么时候最慢"><a href="#什么时候最慢" class="headerlink" title="什么时候最慢"></a>什么时候最慢</h3><p>当输入的数据被分配到了同一个桶中。</p></li><li><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p>元素分布在桶中：</p></li></ol><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/bucketSort1.png" alt></p><p>​        然后，元素在每个桶中排序：</p><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/bucketSort2.png" alt></p><h3 id="2-Java-代码实现"><a href="#2-Java-代码实现" class="headerlink" title="2.Java 代码实现"></a>2.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基数排序-1"><a href="#基数排序-1" class="headerlink" title="基数排序"></a><h id="10">基数排序</h></h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1.基数排序 vs 计数排序 vs 桶排序"></a>1.基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="2-动图演示-8"><a href="#2-动图演示-8" class="headerlink" title="2.动图演示"></a>2.动图演示</h3><p><img src="/2020/02/26/%E6%8E%92%E5%BA%8F/radixSort.gif" alt="基数排序"></p><h3 id="3-Java-代码实现-8"><a href="#3-Java-代码实现-8" class="headerlink" title="3.Java 代码实现"></a>3.Java 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;center&gt;目录&lt;/center&gt;&lt;/h1&gt;&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计</title>
    <link href="http://yoursite.com/2020/02/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/02/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-24T05:46:27.000Z</published>
    <updated>2020-02-24T05:49:05.756Z</updated>
    
    <content type="html"><![CDATA[<p>To be continue……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;To be continue……&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="经验" scheme="http://yoursite.com/categories/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E7%BB%8F%E9%AA%8C/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBean生命周期</title>
    <link href="http://yoursite.com/2020/02/24/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2020/02/24/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-02-24T05:27:08.000Z</published>
    <updated>2020-02-24T05:45:47.945Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="实例化-Instantiation"><a href="#实例化-Instantiation" class="headerlink" title="实例化 Instantiation"></a>实例化 Instantiation</h3></li><li><h3 id="属性赋值-Populate"><a href="#属性赋值-Populate" class="headerlink" title="属性赋值 Populate"></a>属性赋值 Populate</h3></li><li><h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化 Initialization"></a>初始化 Initialization</h3></li><li><h3 id="销毁-Destruction"><a href="#销毁-Destruction" class="headerlink" title="销毁 Destruction"></a>销毁 Destruction</h3></li></ol><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><p>主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p><ol><li>createBeanInstance() -&gt; 实例化</li><li>populateBean() -&gt; 属性赋值</li><li>initializeBean() -&gt; 初始化</li></ol><p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的Spring源码都将忽略无关部分，便于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p><hr><h2 id="常用扩展点"><a href="#常用扩展点" class="headerlink" title="常用扩展点"></a>常用扩展点</h2><h4 id="第一大类：影响多个Bean的接口"><a href="#第一大类：影响多个Bean的接口" class="headerlink" title="第一大类：影响多个Bean的接口"></a>第一大类：影响多个Bean的接口</h4><p>这两兄弟可能是Spring扩展中<strong>最重要</strong>的两个接口！InstantiationAwareBeanPostProcessor作用于<strong>实例化</strong>阶段的前后，BeanPostProcessor作用于<strong>初始化</strong>阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：</p><p><img src="/2020/02/24/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img1.webp" alt></p><p>InstantiationAwareBeanPostProcessor实际上继承了BeanPostProcessor接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响，图中省略了从BeanPostProcessor继承的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InstantiationAwareBeanPostProcessor extends BeanPostProcessor</span><br></pre></td></tr></table></figure><h4 id="第二大类：只调用一次的接口"><a href="#第二大类：只调用一次的接口" class="headerlink" title="第二大类：只调用一次的接口"></a>第二大类：只调用一次的接口</h4><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。<br> 第二大类中又可以分为两类：</p><ol><li>Aware类型的接口</li><li>生命周期接口</li></ol><h5 id="无所不知的Aware"><a href="#无所不知的Aware" class="headerlink" title="无所不知的Aware"></a>无所不知的Aware</h5><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！</p><h5 id="简单的两个生命周期接口"><a href="#简单的两个生命周期接口" class="headerlink" title="简单的两个生命周期接口"></a>简单的两个生命周期接口</h5><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p><ol><li>InitializingBean 对应生命周期的初始化阶段。</li><li>DisposableBean 类似于InitializingBean，对应生命周期的销毁阶段 。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Bean的生命周期分为<code>四个阶段</code>和<code>多个扩展点</code>。扩展点又可以分为<code>影响多个Bean</code>和<code>影响单个Bean</code>。整理如下：<br> 四个阶段</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>多个扩展点</p><ul><li>影响多个Bean<ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li>影响单个Bean<ul><li>Aware<ul><li>Aware Group1<ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul></li><li>Aware Group2<ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</li></ul></li></ul></li><li>生命周期<ul><li>InitializingBean</li><li>DisposableBean</li></ul></li></ul></li></ul><hr><p>参考：<a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">https://www.jianshu.com/p/1dec08d290c1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;实例化-Instantiation&quot;&gt;&lt;a href=&quot;#实例化-Instantiation&quot; class=&quot;headerlink&quot; title=&quot;实例化 Instantiation&quot;&gt;&lt;/a&gt;实例化 Instantiation&lt;/h3&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2020/02/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/02/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-02-22T15:51:40.000Z</published>
    <updated>2020-02-23T06:31:04.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用线程池："><a href="#使用线程池：" class="headerlink" title="使用线程池："></a>使用线程池：</h2><p>​    1.自己定义线程池类实现XX线程池，设置参数…进行操作<br>​    2.使用Executors工具类获取线程池对象</p><h2 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h2><p>​    1.线程重用，避免多次新建销毁<br>​    2.线程并发数控制，并且能对线程管理</p><p>线程池构造参数详解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 线程池中的核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,                    // 线程池中允许的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,                    // 线程空闲时的存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,                          // keepAliveTime的单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,      // 用来保存等待被执行的任务的阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,            // 创建线程的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler)</span>       <span class="comment">// 线程池的饱和(拒绝)策略</span></span></span><br></pre></td></tr></table></figure><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>​    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数<br>​    等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等<br>​    待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有<br>​    核心线程。当线程数小于等于corePoolSize时，默认情况下线程会一直存活在线程池中，即时线<br>​    程处于空闲状态。如果allowCoreThreadTimeOut被设置为true时，无论线程数多少，那么线程处<br>​    于空闲状态超过一定时间就会被销毁掉。</p><h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>​    线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在<br>​    线程数大于corePoolSize时才有用；如果allowCoreThreadTimeOut被设置为true时，无论线程数<br>​    多少，线程处于空闲状态超过一定时间就会被销毁掉。</p><h4 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h4><p>​    keepAliveTime的单位。TimeUnit是一个枚举类型，其包括：<br>​    NANOSECONDS ：1微毫秒 = 1微秒 / 1000<br>​    MICROSECONDS ：1微秒 = 1毫秒 / 1000<br>​    MILLISECONDS ：1毫秒 = 1秒 /1000<br>​    SECONDS ：秒<br>​    MINUTES ：分<br>​    HOURS ：小时<br>​    DAYS ：天</p><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>​    用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，如下阻塞队列：<br>​    ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>​    LinkedBlockingQuene：基于链表结构的无界阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>​    SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作<br>​        一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</p><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>​    创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名</p><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>​    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，<br>​        线程池提供了4种策略：<br>​    AbortPolicy：直接抛出异常，默认策略；<br>​    CallerRunsPolicy：用调用者所在的线程来执行任务；<br>​    DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>​    DiscardPolicy：直接丢弃任务</p><hr><h2 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h2><h2 id="此处为使用Executors工具类获取线程池对象，列出5种常用线程池"><a href="#此处为使用Executors工具类获取线程池对象，列出5种常用线程池" class="headerlink" title="(此处为使用Executors工具类获取线程池对象，列出5种常用线程池)"></a>(此处为使用Executors工具类获取线程池对象，列出5种常用线程池)</h2><h4 id="1、newCachedThreadPool"><a href="#1、newCachedThreadPool" class="headerlink" title="1、newCachedThreadPool"></a>1、newCachedThreadPool</h4><p>​    作用：创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的<br>​        ThreadFactory 创建新线程。<br>​    特征：<br>​    （1）线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）<br>​    （2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟）<br>​    （3）当线程池中，没有可用线程，会重新创建一个线程<br>​    创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><h4 id="2、newFixedThreadPool"><a href="#2、newFixedThreadPool" class="headerlink" title="2、newFixedThreadPool"></a>2、newFixedThreadPool</h4><p>​    作用：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads<br>​        线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加<br>​        任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行<br>​        后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。<br>​    特征：<br>​    （1）线程池中的线程处于一定的量，可以很好的控制线程的并发量<br>​    （2）线程可以重复被使用，在显示关闭之前，都将一直存在<br>​    （3）超出一定量的线程被提交时候需在队列中等待<br>​    创建方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads)；<span class="comment">//nThreads为线程的数量 </span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads，ThreadFactory threadFactory)；</span><br><span class="line"><span class="comment">// nThreads为线程的数量，threadFactory创建线程的工厂方式</span></span><br></pre></td></tr></table></figure><h4 id="3、newSingleThreadExecutor"><a href="#3、newSingleThreadExecutor" class="headerlink" title="3、newSingleThreadExecutor"></a>3、newSingleThreadExecutor</h4><p>​    作用：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行<br>​        期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执<br>​        行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，<br>​        可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。<br>​    特征：<br>​    （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行<br>​    创建方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor() ； </span><br><span class="line">Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；<span class="comment">// threadFactory创建线程的工厂方式</span></span><br></pre></td></tr></table></figure><h4 id="4、newScheduleThreadPool"><a href="#4、newScheduleThreadPool" class="headerlink" title="4、newScheduleThreadPool"></a>4、newScheduleThreadPool</h4><p>​    作用： 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。<br>​    特征：<br>​    （1）线程池中具有指定数量的线程，即便是空线程也将保留<br>​    （2）可定时或者延迟执行线程活动<br>​    创建方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool(<span class="keyword">int</span> corePoolSize)；<span class="comment">// corePoolSize线程的个数 </span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)；</span><br><span class="line"><span class="comment">// corePoolSize线程的个数，threadFactory创建线程的工厂</span></span><br></pre></td></tr></table></figure><h4 id="5、newSingleThreadScheduledExecutor"><a href="#5、newSingleThreadScheduledExecutor" class="headerlink" title="5、newSingleThreadScheduledExecutor"></a>5、newSingleThreadScheduledExecutor</h4><p>​    作用： 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。<br>​    特征：<br>​    （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行<br>​    （2）可定时或者延迟执行线程活动<br>​    创建方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadScheduledExecutor() ； </span><br><span class="line">Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；<span class="comment">//threadFactory创建线程的工</span></span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用线程池：&quot;&gt;&lt;a href=&quot;#使用线程池：&quot; class=&quot;headerlink&quot; title=&quot;使用线程池：&quot;&gt;&lt;/a&gt;使用线程池：&lt;/h2&gt;&lt;p&gt;​    1.自己定义线程池类实现XX线程池，设置参数…进行操作&lt;br&gt;​    2.使用Executors
      
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>个人博客攻略</title>
    <link href="http://yoursite.com/2020/02/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2020/02/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/</id>
    <published>2020-02-21T04:45:09.000Z</published>
    <updated>2020-02-26T11:19:11.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本站使用-Hexo-博客框架和-NexT-主题"><a href="#本站使用-Hexo-博客框架和-NexT-主题" class="headerlink" title="本站使用 Hexo 博客框架和 NexT 主题"></a><center>本站使用 Hexo 博客框架和 NexT 主题</center></h3><h3 id="此处用于记录自己建站的一些细节😄"><a href="#此处用于记录自己建站的一些细节😄" class="headerlink" title="此处用于记录自己建站的一些细节😄"></a><center>此处用于记录自己建站的一些细节😄</center></h3><hr><p><a href="#1">1.常用命令</a></p><p><a href="#2">2.添加 daovoice 实现右下角VX实时聊天</a></p><p><a href="#3">3.设置SSH，每当重新部署hexo项目时，不用输入用户名密码</a></p><p><a href="#4">4.文章加密方法</a></p><p><a href="#5">5.访客数、访问量统计</a></p><p><a href="#6">6.使用 CDN 加速 Github Page</a></p><hr><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a><h id="1">常用命令：</h></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面相应的命令可以简化为一个字母表示，如 server 可以用 s 代替</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地启动hexo项目，访问 localhost:4040/ 即可本地访问</span></span><br><span class="line">hexo server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除本地编译好的项目和缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地编译好的项目部署到服务器(github page)</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在_post里新建一个博客页面</span></span><br><span class="line">hexo new xxx</span><br></pre></td></tr></table></figure><hr><h1 id="next-主题美化"><a href="#next-主题美化" class="headerlink" title="next 主题美化"></a><center>next 主题美化</center></h1><h3 id="添加-daovoice-实现右下角VX实时聊天"><a href="#添加-daovoice-实现右下角VX实时聊天" class="headerlink" title="添加 daovoice 实现右下角VX实时聊天"></a><h id="2">添加 daovoice 实现右下角VX实时聊天</h></h3><p>登录 <a href="http://dashboard.daovoice.io/" target="_blank" rel="noopener">http://dashboard.daovoice.io/</a> 注册进入</p><p>打开 ~\themes\next\layout_partials\head.swig ，在末尾添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class="string">"DaoVoiceObject"</span>]=r;i[r]=i[r]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class="built_in">arguments</span>)&#125;,i[r].l=<span class="number">1</span>*<span class="keyword">new</span> <span class="built_in">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="number">0</span>];a.async=<span class="number">1</span>;a.src=g;a.charset=<span class="string">"utf-8"</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"script"</span>,(<span class="string">'https:'</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">"//widget.daovoice.io/widget/0f81ff2f.js"</span>,<span class="string">"daovoice"</span>)</span></span><br><span class="line"><span class="actionscript">  daovoice(<span class="string">'init'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      app_id: <span class="string">"&#123;&#123;theme.daovoice_app_id&#125;&#125;"</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">  daovoice(<span class="string">'update'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>打开next主题配置文件，末尾添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Online contact</span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="comment"># 此处为daovoice获取的app_id</span></span><br></pre></td></tr></table></figure><hr><h3 id="设置SSH，每当重新部署hexo项目时，不用输入用户名密码"><a href="#设置SSH，每当重新部署hexo项目时，不用输入用户名密码" class="headerlink" title="设置SSH，每当重新部署hexo项目时，不用输入用户名密码"></a><h id="3">设置SSH，每当重新部署hexo项目时，不用输入用户名密码</h></h3><p>鼠标邮件 Git Bash Here</p><p>使用 ssh-keygen 生成密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"745965645@qq.com"</span></span></span><br></pre></td></tr></table></figure><p>按提示操作，如果想没密码则一直按Enter</p><p>如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成的公钥、私钥位置</span></span><br><span class="line">Your identification has been saved in /c/Users/74596/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/74596/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure><p>设置 Github 项目的 Deploy Key</p><p>在 jokerleei.github.io<code>的首页菜单栏中点击 Settings --&gt; Deploy keys --&gt; Add deploy key，然后将生成的</code>id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥（记得勾选 Allow write access）。</p><p>修改hexo配置文件_config.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jokerleei/jokerleei.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><hr><h3 id="文章加密方法"><a href="#文章加密方法" class="headerlink" title="文章加密方法"></a><h id="4">文章加密方法</h></h3><p>切到hexo项目路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><p>全局配置文件_config.yml中添加如下字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用文章加密</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在文章开头添加如下描述</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">password:</span> <span class="string">love</span> <span class="comment"># 密码</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">密码：love</span> <span class="comment"># 摘要</span></span><br><span class="line"><span class="attr">message:</span>  <span class="string">输入密码，查看文章</span> <span class="comment"># placeholder</span></span><br></pre></td></tr></table></figure><hr><h3 id="访客数、访问量统计"><a href="#访客数、访问量统计" class="headerlink" title="访客数、访问量统计"></a><h id="5">访客数、访问量统计</h></h3><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud官网</a>注册登录</p><p>获取 app_id 和 app_key，在主题配置文件中配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show number of visitors to each article.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: CDRocj9P5t8f77lE70CFvaC2-gzGzoHsz</span><br><span class="line">  app_key: mHWzbxsbaVRQb7BnOyT9y5A8</span><br></pre></td></tr></table></figure><p>然后在 leancloud 的控制台中的存储内添加一个<code>Counter</code>的<code>class</code>，这样就可以记录我们每页的浏览量了。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;本站使用-Hexo-博客框架和-NexT-主题&quot;&gt;&lt;a href=&quot;#本站使用-Hexo-博客框架和-NexT-主题&quot; class=&quot;headerlink&quot; title=&quot;本站使用 Hexo 博客框架和 NexT 主题&quot;&gt;&lt;/a&gt;&lt;center&gt;本站使用 Hexo
      
    
    </summary>
    
    
      <category term="经验" scheme="http://yoursite.com/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2020-02-20T10:53:13.000Z</published>
    <updated>2020-02-21T03:34:32.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/demo.png" alt></p><hr><h2 id="MySql-分析-sql-语句效率"><a href="#MySql-分析-sql-语句效率" class="headerlink" title="MySql 分析 sql 语句效率"></a>MySql 分析 sql 语句效率</h2><h3 id="MySql内部函数-explain（查询sql的执行计划）使用方法以及返回各列的含义"><a href="#MySql内部函数-explain（查询sql的执行计划）使用方法以及返回各列的含义" class="headerlink" title="MySql内部函数 explain（查询sql的执行计划）使用方法以及返回各列的含义"></a>MySql内部函数 explain（查询sql的执行计划）使用方法以及返回各列的含义</h3><p>使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>table:显示这一行的数据是关于哪张表的<br>type:这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index 和ALL<br>possible_keys:显示可能应用在这张表中的索引。如果为空，没有可能的索引。<br>key:实际使用的索引。如果为NULL,则没有使用索引。<br>keyjen:使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref:显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows: MYSQL认为必须检查的用来返回请求数据的行数</p><hr><h2 id="SQL-语句优化"><a href="#SQL-语句优化" class="headerlink" title="SQL 语句优化"></a>SQL 语句优化</h2><ol><li><p>不使用select *，会生成无用结果</p></li><li><p>where 中不用 null（全表扫描）</p><p>如：    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>为id建立默认值0，然后使用默认值代替null：    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>where 中不用!=或&lt;&gt;（全表扫描）</p></li><li><p>where 中不用 or （全表扫描）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>改为 union：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>不用 in 和 not in（全表扫描）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">--连续数值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b) <span class="comment">--不连续数值</span></span><br></pre></td></tr></table></figure><p>对于连续的数值，改为between：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>对于不连续的数值，改为exist：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num)</span><br></pre></td></tr></table></figure></li><li><p>模糊查询不能在开头：%xxx%（全表扫描），用 xxx%</p></li><li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算（全表扫描）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol><li><p>选择合适列建立索引</p><ol><li>首先应考虑在 where 、order by、group by、on 从句中出现的列上建立索引。</li><li>索引字段越小越好，因为数据库里的数据是以页存储的，如果IO一次读取一页的数据很多，这样的话就可以提高服务器IO的效率。</li><li>离散度大的列放到联合索引的前面</li></ol></li><li><p>索引的维护和优化</p><ol><li><p>重复索引<br>重复索引是指相同的列以相同顺序建立的同类型索引，如下表的 primary key 和 ID 列上的索引就是重复索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,  <span class="comment">--primary key(包含unique)</span></span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">unique</span>(<span class="keyword">id</span>) <span class="comment">--unique</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure></li><li><p>冗余索引<br>冗余索引是指多个索引的前缀相同，或是在联合索引中包含了主键的索引，如下表的 key(name, id) 就是一个冗余索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>, <span class="comment">--创建primary key时自带主键索引</span></span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">key</span>(<span class="keyword">name</span>, <span class="keyword">id</span>) <span class="comment">--联合索引包含主键索引</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h2 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h2><ol><li><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><p>数据类型的选择，重点在于<strong>合适</strong>二字，如何确定选择的数据类型是否合适?</p><ol><li>使用可以存下你的数据的最小的数据类型。</li><li>使用简单的数据类型。Int要比varchar类型在mysql处理上简单。</li><li>尽可能的使用not null定义字段。</li><li>尽量少用text类型，非用不可时最好考虑分表。</li></ol><p>例子：</p><ol><li><p>时间使用 int (timestamp) 类型</p><p>利用 FROM_UNIXTIME()、UNIX_TIMESTAMP() 两个函数进行转换</p></li><li><p>ip 地址使用 bigint 类型</p><p>利用 INET_ATON()、INET_NTOA() 两个函数进行转换</p></li></ol></li><li><h4 id="表的范式化（主要让设计的表满足第三范式）"><a href="#表的范式化（主要让设计的表满足第三范式）" class="headerlink" title="表的范式化（主要让设计的表满足第三范式）"></a>表的范式化（主要让设计的表满足第三范式）</h4></li><li><h4 id="分库、分表（垂直拆分、水平拆分）"><a href="#分库、分表（垂直拆分、水平拆分）" class="headerlink" title="分库、分表（垂直拆分、水平拆分）"></a>分库、分表（垂直拆分、水平拆分）</h4><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分原则：</p><ol><li>把不常用的字段单独存放到一个表中</li><li>把大字段独立存放在一个表中</li><li>把经常一起使用的字段存放在一个表中</li></ol><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>拆分方法：</p><ol><li>对 id 进行 hash 运算，若拆成5个表则使用 mod(id, 5) 取出 0-4 值</li><li>针对不同的 hashId 把数据存储在不同的表中</li></ol><p>问题：</p><ol><li>跨分区表查询</li><li>统计及后台报表</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库优化&quot;&gt;&lt;a href=&quot;#数据库优化&quot; class=&quot;headerlink&quot; title=&quot;数据库优化&quot;&gt;&lt;/a&gt;数据库优化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>事务汇总</title>
    <link href="http://yoursite.com/2020/02/20/%E4%BA%8B%E5%8A%A1%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/02/20/%E4%BA%8B%E5%8A%A1%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-20T10:19:00.000Z</published>
    <updated>2020-03-04T15:41:40.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="😄目录😄"><a href="#😄目录😄" class="headerlink" title="😄目录😄"></a><center>😄目录😄</center></h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><center><a href="#1">ACID</a></center></h2><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><center><a href="#2">事务隔离级别</a></center></h2><h2 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a><center><a href="#3">脏读、不可重复读、幻读</a></center></h2><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a><center><a href="#4">事务传播行为</a></center></h2><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><center><a href="#5">MVCC</a></center></h2><hr><h1 id="ACID-1"><a href="#ACID-1" class="headerlink" title="ACID"></a><h id="1">ACID</h></h1><h2 id="Atomicity（原子性）"><a href="#Atomicity（原子性）" class="headerlink" title="Atomicity（原子性）"></a>Atomicity（原子性）</h2><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p>如，A向B转钱，在事务中的扣款和加款两条语句，要么都执行，要么都不执行。</p><h2 id="Consistency（一致性）"><a href="#Consistency（一致性）" class="headerlink" title="Consistency（一致性）"></a>Consistency（一致性）</h2><p>事务前后数据的完整性必须保持一致。</p><p>如，A和B存款总额为1000，A向B转钱，无论失败，最终A和B的存款总额依然为1000。</p><h2 id="Isolation（隔离性）"><a href="#Isolation（隔离性）" class="headerlink" title="Isolation（隔离性）"></a>Isolation（隔离性）</h2><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p><p><a href="#2">事务隔离级别</a> 用于控制事务间的隔离性。</p><h2 id="Durability（持久性）"><a href="#Durability（持久性）" class="headerlink" title="Durability（持久性）"></a>Durability（持久性）</h2><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p><hr><h1 id="事务隔离级别-1"><a href="#事务隔离级别-1" class="headerlink" title="事务隔离级别"></a><h id="2">事务隔离级别</h></h1><h6 id="事务隔离级别分为四种（级别递增）："><a href="#事务隔离级别分为四种（级别递增）：" class="headerlink" title="事务隔离级别分为四种（级别递增）："></a>事务隔离级别分为四种（级别递增）：</h6><ol><li>Read Uncommitted（未提交读） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。</li><li>READ COMMITTED （提交读）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。</li><li>REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。</li><li>Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大。</li></ol><table><thead><tr><th align="left">隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="left">读未提交（Read uncommitted）</td><td>√</td><td>√</td><td>√</td></tr><tr><td align="left">读已提交（Read committed）</td><td>×</td><td>√</td><td>√</td></tr><tr><td align="left">重复读（Repeatable read）</td><td>×</td><td>×</td><td>√</td></tr><tr><td align="left">串行化（Serializable）</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>低级别的隔离一般支持更高的并发处理，并拥有更低的系统开销。高级别的隔离可靠性较高，但系统开销较大。</p><h3 id="MySQL-默认事务隔离级别：重复读（Repeatable-read）"><a href="#MySQL-默认事务隔离级别：重复读（Repeatable-read）" class="headerlink" title="MySQL 默认事务隔离级别：重复读（Repeatable read）"></a>MySQL 默认事务隔离级别：重复读（Repeatable read）</h3><h3 id="Oracle-默认事务隔离级别：读已提交（Read-committed）"><a href="#Oracle-默认事务隔离级别：读已提交（Read-committed）" class="headerlink" title="Oracle 默认事务隔离级别：读已提交（Read committed）"></a>Oracle 默认事务隔离级别：读已提交（Read committed）</h3><hr><h1 id="脏读、不可重复读、幻读-1"><a href="#脏读、不可重复读、幻读-1" class="headerlink" title="脏读、不可重复读、幻读"></a><h id="3">脏读、不可重复读、幻读</h></h1><h3 id="脏读（前后多次读取，数据内容不一致-修改者事务先开启）"><a href="#脏读（前后多次读取，数据内容不一致-修改者事务先开启）" class="headerlink" title="脏读（前后多次读取，数据内容不一致/修改者事务先开启）"></a>脏读（前后多次读取，数据内容不一致/修改者事务先开启）</h3><p>一个事务读取到了另外一个事务没有提交的数据<br>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><h3 id="不可重复读（前后多次读取，数据内容不一致-修改者事务后开启）"><a href="#不可重复读（前后多次读取，数据内容不一致-修改者事务后开启）" class="headerlink" title="不可重复读（前后多次读取，数据内容不一致/修改者事务后开启）"></a>不可重复读（前后多次读取，数据内容不一致/修改者事务后开启）</h3><p>在同一事务中，两次读取同一数据，得到内容不同<br>事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致</p><h3 id="幻读（前后多次读取，数据总量不一致-修改者事务后开启）"><a href="#幻读（前后多次读取，数据总量不一致-修改者事务后开启）" class="headerlink" title="幻读（前后多次读取，数据总量不一致/修改者事务后开启）"></a>幻读（前后多次读取，数据总量不一致/修改者事务后开启）</h3><p>同一事务中，用同样的操作读取两次，得到的记录数不相同<br>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样</p><h5 id="不可重复读和幻读区别：不可重复读针对update，幻读针对insert和delete"><a href="#不可重复读和幻读区别：不可重复读针对update，幻读针对insert和delete" class="headerlink" title="不可重复读和幻读区别：不可重复读针对update，幻读针对insert和delete"></a><u>不可重复读和幻读区别：不可重复读针对update，幻读针对insert和delete</u></h5><hr><h1 id="事务传播行为-1"><a href="#事务传播行为-1" class="headerlink" title="事务传播行为"></a><h id="4">事务传播行为</h></h1><ul><li><strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。</li><li><strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li><strong>PROPAGATION_MANDATORY</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</li></ul><hr><h1 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a><h id="5">MVCC</h></h1><h3 id="MVCC（Multi-Version-Concurrency-Control）：多版本并发控制"><a href="#MVCC（Multi-Version-Concurrency-Control）：多版本并发控制" class="headerlink" title="MVCC（Multi-Version Concurrency Control）：多版本并发控制"></a>MVCC（Multi-Version Concurrency Control）：多版本并发控制</h3><p>大多数的MySQL事务型存储引擎，如InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制。事实上，他们都和另外一种用来增加并发性的被称为“多版本并发控制（MVCC）”的机制来一直使用。MVCC不只使用在MySQL 中，Oracle，PostgreSQL以及其他一些数据为系统也同样使用它。 </p><h3 id="基本特征（乐观锁）"><a href="#基本特征（乐观锁）" class="headerlink" title="基本特征（乐观锁）"></a>基本特征（乐观锁）</h3><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本。</li><li>修改时Copy出当前版本随意修改，各个事务之间无干扰。</li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><h3 id="MySQL-中的-MVCC"><a href="#MySQL-中的-MVCC" class="headerlink" title="MySQL 中的 MVCC"></a>MySQL 中的 MVCC</h3><p>数据库默认隔离级别：<strong>RR（Repeatable Read，可重复读），MVCC主要适用于Mysql的RC,RR隔离级别</strong></p><h5 id="InnoDB存储引擎MVCC的实现策略"><a href="#InnoDB存储引擎MVCC的实现策略" class="headerlink" title="InnoDB存储引擎MVCC的实现策略"></a>InnoDB存储引擎MVCC的实现策略</h5><p>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p><p>隐藏列：</p><ul><li>trx_id（版本链）</li><li>roll_pointer（上一个版本的地址）</li></ul><p><img src="/2020/02/20/%E4%BA%8B%E5%8A%A1%E6%B1%87%E6%80%BB/mvcc.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;😄目录😄&quot;&gt;&lt;a href=&quot;#😄目录😄&quot; class=&quot;headerlink&quot; title=&quot;😄目录😄&quot;&gt;&lt;/a&gt;&lt;center&gt;😄目录😄&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>B Tree、B+ Tree、B* Tree</title>
    <link href="http://yoursite.com/2020/02/20/B%20Tree/"/>
    <id>http://yoursite.com/2020/02/20/B%20Tree/</id>
    <published>2020-02-20T09:02:14.000Z</published>
    <updated>2020-02-20T10:17:39.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-Tree、B-Tree、B-Tree"><a href="#B-Tree、B-Tree、B-Tree" class="headerlink" title="B Tree、B+ Tree、B* Tree"></a>B Tree、B+ Tree、B* Tree</h1><h5 id="B-树索引是B-树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B-树中的B代表平（balance），而不是二叉（binary），因为B-树是从最早的平衡二叉树演化而来的。在讲B-树之前必须先了解二叉查找树、平衡二叉树（AVL-Tree）和平衡多路查找树（B-Tree），B-树即由这些树逐步优化而来。"><a href="#B-树索引是B-树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B-树中的B代表平（balance），而不是二叉（binary），因为B-树是从最早的平衡二叉树演化而来的。在讲B-树之前必须先了解二叉查找树、平衡二叉树（AVL-Tree）和平衡多路查找树（B-Tree），B-树即由这些树逐步优化而来。" class="headerlink" title="B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVL Tree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。"></a>B+树索引是B+树在<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVL Tree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。</h5><br><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h5 id="二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。"><a href="#二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。" class="headerlink" title="二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。"></a>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。</h5><p>如下图所示是一棵平衡查找树</p><p><img src="/2020/02/20/B%20Tree/Tree.png" alt></p><p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p><p>二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：</p><p><img src="/2020/02/20/B%20Tree/AVL.png" alt></p><p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。</p><br><h1 id="平衡二叉树-AVL-Tree"><a href="#平衡二叉树-AVL-Tree" class="headerlink" title="平衡二叉树 (AVL Tree)"></a>平衡二叉树 (AVL Tree)</h1><h5 id="平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差-lt-1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1"><a href="#平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差-lt-1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1" class="headerlink" title="平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1"></a>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1</h5><p><img src="/2020/02/20/B%20Tree/AVL2.png" alt></p><br><h1 id="平衡多路查找树（B-Tree）"><a href="#平衡多路查找树（B-Tree）" class="headerlink" title="平衡多路查找树（B-Tree）"></a>平衡多路查找树（B-Tree）</h1><p><img src="/2020/02/20/B%20Tree/BTree.png" alt></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVL Tree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><br><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h1><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="/2020/02/20/B%20Tree/B+Tree.png" alt></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2<del>4层。<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">mysql</a>的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1</del>3次磁盘I/O操作。</p><p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary  index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p><br><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B* Tree"></a>B* Tree</h1><h5 id="是B-树的变体，在B-树的非根和非叶子结点再增加指向兄弟的指针"><a href="#是B-树的变体，在B-树的非根和非叶子结点再增加指向兄弟的指针" class="headerlink" title="是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针"></a>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</h5><h5 id="B-树分配新结点的概率比B-树要低，空间使用率更高"><a href="#B-树分配新结点的概率比B-树要低，空间使用率更高" class="headerlink" title="B*树分配新结点的概率比B+树要低，空间使用率更高"></a>B*树分配新结点的概率比B+树要低，空间使用率更高</h5><br><hr><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>这都是由于B+树和B具有这不同的存储结构所造成的区别，以一个m阶树为例。</p><ol><li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。【注：此处有争议，B+树到底是与B 树n-1个关键字有n棵子树保持一致，还是B+树n个关键字的结点中含有n棵子树；两种定义都可以，只要自己实现的时候统一用一种就行】。</li><li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。而且B+树叶子结点上还存储了指向与该结点相邻的后一个叶子结点的指针信息，这主要是为了加快检索多个相邻叶子结点的效率考虑。</li><li>分支结点的构造不同；分支结点并不存储真正的信息，仅包含着索引信息，其保存着叶子节点的最小值作为索引及其儿子指针（指的是磁盘块的偏移量）。【注：此处有争议，是以最大值还是最小值作为索引看个人实现】。</li><li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li><li>用处不用：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引</li></ol><h2 id="为什么说B-树比B-树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-树比B-树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</h2><p>1) B+树的磁盘读写代价更低<br>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>2) B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B-Tree、B-Tree、B-Tree&quot;&gt;&lt;a href=&quot;#B-Tree、B-Tree、B-Tree&quot; class=&quot;headerlink&quot; title=&quot;B Tree、B+ Tree、B* Tree&quot;&gt;&lt;/a&gt;B Tree、B+ Tree、B* Tree&lt;/
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2020/02/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-19T05:06:19.000Z</published>
    <updated>2020-02-27T05:10:18.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。</p><p><strong>特点</strong></p><ul><li><p>构造器私有</p></li><li><p>在本类中提前(延迟)构造对象</p></li><li><p>对外提供获取本类对象实例的静态方法</p></li></ul><h3 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h3><h5 id="线程安全-浪费资源"><a href="#线程安全-浪费资源" class="headerlink" title="线程安全 浪费资源"></a>线程安全 浪费资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="普通懒汉"><a href="#普通懒汉" class="headerlink" title="普通懒汉"></a>普通懒汉</h3><h5 id="线程不安全，延迟初始化"><a href="#线程不安全，延迟初始化" class="headerlink" title="线程不安全，延迟初始化"></a>线程不安全，延迟初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="升级版-双重锁模式"><a href="#升级版-双重锁模式" class="headerlink" title="升级版 (双重锁模式)"></a>升级版 (双重锁模式)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<code>singleton=new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        只有第一次调用getInstance方法时，虚拟机才加载 SingletonHolder并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。</p><h3 id="静态内部类升级版"><a href="#静态内部类升级版" class="headerlink" title="静态内部类升级版"></a>静态内部类升级版</h3><p>​        新建对象方法有4种：new、反射、反序列化、clone</p><p>​        上面得静态内部类法和双重锁法阻止了new，不能clone因为没有实现Cloneable接口</p><p>​        还剩下反射和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态成员内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单例变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法,保证不被其他类使用构造器实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当私有化构造方法被反射入侵时，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (SingletonHolder.instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例模式对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化流调用，返回指定的对象，防止反序列化破坏单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如果想支持clone，那么实现Cloneable接口然后在重写的方法里返回SingletonHolder实例即可</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上</p><ul><li>枚举类隐藏了私有的构造器。</li><li>枚举类的域 是相应类型的一个实例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实
      
    
    </summary>
    
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
